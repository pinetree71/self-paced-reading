<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Self-paced reading — hosted</title>
  <style>
    body{background:#000;color:#fff;font-family:Helvetica,Arial,sans-serif;margin:0;height:100vh;display:flex;align-items:center;justify-content:center}
    #screen{max-width:1000px;padding:24px;text-align:center}
    .big{font-size:36px;line-height:1.4}
    .word{font-size:48px;margin:40px 0}
    .instr{font-size:38px;white-space:pre-wrap;}
    .hidden{display:none}
    .fix{font-size:48px}
    button{font-size:18px;padding:10px 14px;margin:8px}

  </style>
</head>
<body>
  <div id="screen">
    <div id="setup" class="big">
      <div class="instr">Welcome to the experiment! Please contact the researcher to receive your participant ID.</div>
      <div style="margin-top:18px;text-align:left">
        <label>Participant ID: <input id="participant" type="text" autocomplete="off"></label><br>
      </div>
      <div style="margin-top:25px"><button id="startBtn">Start</button></div>
      <div id="status" style="margin-top:12px;color:#ccc"></div>
    </div>

    <div id="instrPages" class="hidden">
      <div id="instrText" class="instr"></div>
    </div>

	<div id="pauseScreen" class="hidden big">
	  <div id="pauseText">Press SPACE to continue</div>
	</div>	

    <div id="trialScreen" class="hidden">
	  <div id="progress"></div>
	  <div id="fixation" class="fix hidden">+</div>
	  <div id="word" class="word"></div>
	</div>

	<div id="practiceFeedback" 
		 class="instr hidden" 
		 style="margin-top:20px; font-size:24px; text-align:center;">
	</div>

    <div id="judgment" class="hidden">
      <div class="big">Was the sentence meaningful?</div>
      <div class="instr" style="margin-top:14px"><span id="leftKey"></span> &nbsp;&nbsp;&nbsp; <span id="rightKey"></span></div>
    </div>

	<div id="finalConsentScreen" class="hidden big" style="text-align:center; padding:24px;">
	  You have reached the end of the experiment.<br><br>
	  After this, it will no longer be possible to withdraw your consent to participate.<br> If you want to withdraw, close this window immediately.<br><br>
	  Press SPACE to continue.
	</div>
	
	<div id="savingScreen" class="hidden big" style="text-align:center; padding:24px;">
	  Saving data... Please wait.
	</div>

    <div id="endScreen" class="hidden big">
      Thank you! Experiment finished. <br>
	  You may now close this window and proceed to the language questionnaire.<br><br>
	  If you want to, you can download your data below.
      <div style="margin-top:12px"><button id="downloadBtn">Download data (CSV)</button></div>
    </div>
  </div>

<script>
// -------------------- Utility: simple CSV parser --------------------
function parseCSV(text){
  const lines = text.trim().split(/\r?\n/);
  const header = lines[0].split(/,\s*/).map(h => h.replace(/^\uFEFF/, '').trim());
  const rows = lines.slice(1).map(line => {
    // naive split—this assumes no commas embedded in fields; if you have such fields, use PapaParse
    const cols = line.split(/,\s*/);
    const obj = {};
    header.forEach((h,i)=> obj[h]= (i<cols.length? cols[i].trim() : ''));
    return obj;
  });
  return rows;
}

// -------------------- Data and config --------------------
let participant = '';
let language_order = 'PL_first';
let key_mapping = 'F_yes_J_no';
let yes_key='f', no_key='j';
let left_desc = '', right_desc = '';

let stimuliPL=[], stimuliENG=[], practiceStimuli=[];
let blockOrder=[];
let results=[]; // one row per word

const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');

// -------------------- Load CSV files via fetch --------------------
async function loadCSVfile(fname){
  const res = await fetch(fname);
  if(!res.ok) throw new Error('Cannot load '+fname+' (HTTP '+res.status+')');
  const txt = await res.text();
  return parseCSV(txt);
}

// -------------------- Avoid consecutive same-target (JS port) --------------------
function avoidConsecutive(records, maxAttempts=1000){
  if(records.length<=1) return records.slice();
  // quick random tries
  for(let attempt=0; attempt<maxAttempts; attempt++){
    const arr = records.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    let ok=true;
    for(let i=1;i<arr.length;i++){
      if((arr[i].target||'') === (arr[i-1].target||'')) { ok=false; break; }
    }
    if(ok) return arr;
  }

  // fallback greedy interleave
  const groups = {};
  records.forEach(r=>{ const t = r.target||''; groups[t]=groups[t]||[]; groups[t].push(r); });
  // build array of [count,target]
  const heap = Object.keys(groups).map(k=>({k,count:groups[k].length}));
  // sort descending by count
  heap.sort((a,b)=>b.count-a.count);
  const result = [];
  let prev = null;
  while(heap.length){
    const cur = heap.shift();
    const item = groups[cur.k].pop();
    result.push(item);
    if(prev) { heap.push(prev); prev=null; }
    if(groups[cur.k].length>0){ prev = {k:cur.k, count: groups[cur.k].length}; heap.sort((a,b)=>b.count-a.count); }
  }
  // last resort: return result (may have duplicates adjacent)
  return result;
}

function splitIntoBlocksPreservingAdjacency(records, nBlocks=2){
  const ordered = avoidConsecutive(records);
  const total = ordered.length;
  const base = Math.floor(total / nBlocks);
  const blocks = [];
  let start=0;
  for(let i=0;i<nBlocks;i++){
    let end = start + base;
    if(i===nBlocks-1) end = total;
    blocks.push(ordered.slice(start,end));
    start = end;
  }
  return blocks;
}

// -------------------- ID validation ----------------------
function validateParticipantID(id){
    const regex = /^[a-z0-9]{5}$/;
    return regex.test(id);
}

const participantDB = {
  "lf5bu":  { language_order: "ENG_first", key_mapping: "F_yes_J_no", sheet_id: "1kB-6UnK_rJ1WdcJOZYgi7AVc8FabncG3OCDmSz4YYbk" },
  "ihrwz":  { language_order: "PL_first", key_mapping: "F_yes_J_no", sheet_id: "199zJ7trScnoUIsY-tTlSr1pmKbrnRitnH7Qjz4ElQAI" },
  "u9hzp":  { language_order: "ENG_first", key_mapping: "F_yes_J_no", sheet_id: "1X0DU1-s7uAUaULIuGXLOQkAMatbrCWeLiCwtUNyyGcY" },
  "jtw1q":  { language_order: "PL_first", key_mapping: "J_yes_F_no", sheet_id: "19EHAKHS-yS0rHdd4LK9B63zuWbIEpOJvP6N52dRPlb4" },
  "yp6ji":  { language_order: "PL_first", key_mapping: "F_yes_J_no", sheet_id: "1-I3vrIz8USc6zyxHBg8xOKVn9GVaSTQfZA-RfDYeBhk" },
  "4jxjt":  { language_order: "ENG_first", key_mapping: "J_yes_F_no", sheet_id: "1ppZKyC9iU5RAwH3Jn0CzBfgDz-Hm8lvdqTYJezBRKL8" },
  "f4xzp":  { language_order: "ENG_first", key_mapping: "F_yes_J_no", sheet_id: "1xdMTUIatHMXutWVY3k1myFPP3lIad6GmlaveHDSncek" }
  "ldm12":  { language_order: "PL_first", key_mapping: "J_yes_F_no", sheet_id: "1iI7dI5QULDfcZ70fPIOUFAgnbsYEI6OALFeyUFpGREo" },
  "ml3yd":  { language_order: "PL_first", key_mapping: "F_yes_J_no", sheet_id: "1fTngAUSURGm_HOvhghQrQESTQtZhHesAG78u3hrJ4Ow" },
  "9mlre":  { language_order: "ENG_first", key_mapping: "J_yes_F_no", sheet_id: "1aMmW1pfStgMBkIvQP5fUVTBVRIEji9bkww53vfbipvg" },
  "do66t":  { language_order: "ENG_first", key_mapping: "F_yes_J_no", sheet_id: "1H593vD5THOEpR0i-i3dUmc6a97bnjElExDYf1Xd9pNI" },
  "jy9zn":  { language_order: "PL_first", key_mapping: "J_yes_F_no", sheet_id: "1qC-YmDFKXgzMjLa3GjJnCAFlSaMMTYIp3xQ4jlhHijc" },
  "anvcj":  { language_order: "PL_first", key_mapping: "F_yes_J_no", sheet_id: "1egeNQlkkTZ66yr5yJ-cGiSbWX7lZVtrkvpWkOxwM1X0" },
  "sx8w7":  { language_order: "ENG_first", key_mapping: "J_yes_F_no", sheet_id: "1-qfAlPj-qr60yBN-77HznahEswvugddqAetl6ikWsAo" },
  "vlddt":  { language_order: "ENG_first", key_mapping: "F_yes_J_no", sheet_id: "1KwRNsTUNfKzbsezrfnTFz6tcOaHbjiIUPJIN1AZv8FU" }};

// -------------------- Presentation / task logic --------------------
const screen = document.getElementById('screen');
const setup = document.getElementById('setup');
const instrPages = document.getElementById('instrPages');
const instrText = document.getElementById('instrText');
const trialScreen = document.getElementById('trialScreen');
const fixationEl = document.getElementById('fixation');
const wordEl = document.getElementById('word');
const progressEl = document.getElementById('progress');
const judgment = document.getElementById('judgment');
const leftKeyEl = document.getElementById('leftKey');
const rightKeyEl = document.getElementById('rightKey');
const endScreen = document.getElementById('endScreen');
const downloadBtn = document.getElementById('downloadBtn');

let currentBlockIndex = 0;
let currentSentenceIndex = 0;
let currentWords = [];
let currentTargetIndex = null;
let currentGlobalTrial = 0;
let blockSequence = [];
let intro_instructions = [];

// instruction pages content
function getInstructions() {
  return [
    `Before beginning, please read the following information.\n\nBy proceeding, you consent to your data being recorded and analysed as part of the study. All data will be fully anonymised and cannot be traced back to you. You may withdraw your consent at any time during the experiment with no consequences.\n\nPress SPACE to continue.`,
    `You will now see the task instructions.\n\nSentences will appear in the centre of the screen, in Polish and in English, one word at a time. Your task is to judge whether the sentence was meaningful by pressing ${left_desc} or ${right_desc}.\n\nPlease place your thumbs on the SPACE bar, your left index finger on F, and your right index finger on J.\n\nPress SPACE to continue.`,
    `You can reveal the next word in a sentence by pressing SPACE. Read at your natural pace and try to be as accurate as possible without slowing down.\n\nPress SPACE to continue.`,
    `You will begin with a short practice block, followed by four experimental blocks. You can take breaks between blocks.\n\nPress SPACE to start practice.`
  ];
}
let instrPageIdx=0;

function showInstructions(){
  setup.classList.add('hidden');
  instrPages.classList.remove('hidden');
  instrPageIdx = 0; instrText.textContent = intro_instructions[instrPageIdx];
}

async function showPause(message){
  const pauseScreen = document.getElementById('pauseScreen');
  const pauseText = document.getElementById('pauseText');
  trialScreen.classList.add('hidden');
  pauseText.textContent = message;
  pauseScreen.classList.remove('hidden');
  await waitForSpace();
  pauseScreen.classList.add('hidden');
  trialScreen.classList.remove('hidden');
}

async function showFinalConsent(){
  const consentScreen = document.getElementById('finalConsentScreen');
  trialScreen.classList.add('hidden');
  consentScreen.classList.remove('hidden');
  await waitForSpace();
  consentScreen.classList.add('hidden');
}

function updateKeyMapping() {
  yes_key = (key_mapping === 'F_yes_J_no') ? 'f' : 'j';
  no_key = (yes_key === 'f') ? 'j' : 'f';

  if (yes_key === 'f') { 
    left_desc = '[F] YES'; 
    right_desc = '[J] NO'; 
  } else { 
    left_desc = '[F] NO'; 
    right_desc = '[J] YES'; 
  }

  // Update the instruction display elements if they exist
  if (leftKeyEl && rightKeyEl) {
    leftKeyEl.textContent = left_desc;
    rightKeyEl.textContent = right_desc;
  }
}

function waitForSpaceOnce(){
  return new Promise(resolve=>{
    function handler(e){
      if(e.code === "Space"){
        e.preventDefault();
        window.removeEventListener("keydown", handler);
        resolve();
      }
    }
    window.addEventListener("keydown", handler);
  });
}

// start: prepare blocks and then show practice
async function startBtnClicked(){
  setup.classList.add('hidden');

  participant = document.getElementById('participant').value.trim();

  // Validate participant ID
  if(!validateParticipantID(participant)){
    alert("Participant ID is invalid.");
    return; // stop experiment if invalid
  }

  // Load participant-specific options if ID is in the database
	if (participantDB[participant]) {
	  language_order = participantDB[participant].language_order;
	  key_mapping = participantDB[participant].key_mapping;
	} else {
	  alert("Unknown participant ID — please contact the researcher.");
	  return;
}

	// Update yes/no keys and labels
	updateKeyMapping();

  intro_instructions = getInstructions();

  leftKeyEl.textContent = left_desc; 
  rightKeyEl.textContent = right_desc;

  statusEl.textContent = 'Loading...';
  try{
    practiceStimuli = await loadCSVfile('practice_stimuli.csv');
    stimuliPL = await loadCSVfile('stimuli_pl.csv');
    stimuliENG = await loadCSVfile('stimuli_eng.csv');

    // add language column if missing
    practiceStimuli.forEach(r=> r.language = r.language || 'PRACTICE');
    stimuliPL.forEach(r=> r.language = 'PL');
    stimuliENG.forEach(r=> r.language = 'ENG');

    // split into blocks
    const plBlocks = splitIntoBlocksPreservingAdjacency(stimuliPL,2);
    const engBlocks = splitIntoBlocksPreservingAdjacency(stimuliENG,2);

    if(language_order==='PL_first'){
      blockSequence = [ ['PL_Block1',plBlocks[0]], ['ENG_Block1',engBlocks[0]], ['PL_Block2',plBlocks[1]], ['ENG_Block2',engBlocks[1]] ];
    } else {
      blockSequence = [ ['ENG_Block1',engBlocks[0]], ['PL_Block1',plBlocks[0]], ['ENG_Block2',engBlocks[1]], ['PL_Block2',plBlocks[1]] ];
    }

    statusEl.textContent = `Loaded stimuli. PL: ${stimuliPL.length} trials, ENG: ${stimuliENG.length} trials.`;

    // show instructions next
    handleInstructions();
  } catch(err){
    statusEl.textContent = 'Error loading CSVs: '+err.message;
    console.error(err);
  }
}

async function handleInstructions(){
  instrPages.classList.remove("hidden");
  instrPageIdx = 0;
  instrText.textContent = intro_instructions[instrPageIdx];

  while(instrPageIdx < intro_instructions.length - 1){
    await waitForSpaceOnce();
    instrPageIdx++;
    instrText.textContent = intro_instructions[instrPageIdx];
  }

  // after last instruction page, press SPACE to start
  await waitForSpaceOnce();
  instrPages.classList.add("hidden");
  startExperiment();
}

startBtn.addEventListener('click', startBtnClicked);

// -------------------- Main experiment flow --------------------
async function startExperiment(){
  // run practice then experimental blocks
  results = [];
  currentGlobalTrial = 0;
  // practice block: present all practice trials sequentially
  await runBlock('Practice', practiceStimuli, true);
  // show post-practice instructions (simple)
  const pauseScreen = document.getElementById('pauseScreen');
  const pauseText = document.getElementById('pauseText');

  pauseText.textContent = 'You have now completed the practice block.\n\nFrom now on, you will not receive feedback on your responses.\n\nPress SPACE when you are ready to begin the next block.';
  trialScreen.classList.add('hidden');
  pauseScreen.classList.remove('hidden');
  await waitForSpace();
  pauseScreen.classList.add('hidden');
  trialScreen.classList.remove('hidden');

  for(let i=0;i<blockSequence.length;i++){
    const [label, block] = blockSequence[i];
    await runBlock(label, block, false);
	if(i < blockSequence.length-1){ 
    pauseText.textContent = 'That was the end of this block.\n\nYou may take a short break.\n\nPress SPACE when you are ready to begin the next block.';
    trialScreen.classList.add('hidden');
    pauseScreen.classList.remove('hidden');
    await waitForSpace();
    pauseScreen.classList.add('hidden');
    trialScreen.classList.remove('hidden');
	}
}

// After last block, show final consent screen
  await showFinalConsent();
  
  // end
  trialScreen.classList.add('hidden');
  await sendResults();
  endScreen.classList.remove('hidden');
}

function presentFixation(){
  fixationEl.classList.remove('hidden');
  wordEl.classList.add('hidden');
}
function hideFixation(){ fixationEl.classList.add('hidden'); wordEl.classList.remove('hidden'); }

function waitForSpace(){
  return new Promise(resolve=>{
    function onKey(e){
      if(e.code==='Space'){ e.preventDefault(); window.removeEventListener('keydown', onKey); resolve(performance.now()); }
    }
    window.addEventListener('keydown', onKey);
  });
}

function waitForChoice(validKeys){
  return new Promise(resolve=>{
    function onKey(e){
      const k = e.key.toLowerCase();
      if(validKeys.includes(k)){ e.preventDefault(); window.removeEventListener('keydown', onKey); resolve({key:k, time:performance.now()}); }
    }
    window.addEventListener('keydown', onKey);
  });
}

async function runBlock(blockName, blockArray, practice=false){
  trialScreen.classList.remove('hidden');
  for(let s=0;s<blockArray.length;s++){
    const trial = blockArray[s];
    const sentence = trial.sentence || '';
    const words = sentence.split(/\s+/).filter(x=>x.length>0);
    const length = words.length;
    if(!practice) currentGlobalTrial += 1;
    const target = trial.target || '';
    const target_inflected = trial.target_inflection || trial.target || '';
    const target_index = words.indexOf(target_inflected);

    // show fixation and wait for space
    presentFixation();
    await waitForSpace();
    hideFixation();

    const wordLevelRows = [];

    for(let i=0;i<words.length;i++){
      wordEl.textContent = words[i];
      // flip / onset time
      const onset = performance.now();
      // wait for space press
      const keyEvent = await waitForSpace();
      const rt = Number(((keyEvent - onset) / 1000).toFixed(7));
      // compute relative target position
      const target_pos = (target_index>=0) ? (i - target_index) : null;
      wordLevelRows.push({
        condition: trial.condition || '',
        language: trial.language || '',
        trial: currentGlobalTrial,
        sentence: sentence,
        sentence_id: trial.id || '',
        target_stereotypicality: trial.target_stereotypicality || '',
        word: words[i],
        word_pos: i+1,
        target: target,
        target_inflection: target_inflected,
        target_pos: target_pos,
        length: length,
        meaningfulness: trial.meaningfulness_M || trial.meaningfulness || '',
        probability: trial.probability_M || trial.probability || '',
        stereotypicality: trial.stereotypicality_M || trial.stereotypicality || '',
        rt: rt
      });
    }

    // show judgment screen
	trialScreen.classList.add('hidden');
	judgment.classList.remove('hidden');
	leftKeyEl.textContent = left_desc;
	rightKeyEl.textContent = right_desc;

	// record onset of judgment screen
	const judgementOnset = performance.now();

	// wait for participant response
	const choice = await waitForChoice([yes_key, no_key]);
	const pressed = choice.key;
	const rt_judgment = Number(((choice.time - judgementOnset) / 1000).toFixed(7));

	// convert key to response
	const response = (pressed === yes_key) ? 'meaningful' : 'not_meaningful';

	// compute accuracy
	const correct_meaning = (trial.condition !== 'sei'); // 'sei' = semantically incorrect
	const participant_meaning = (response === 'meaningful');
	const accuracy = (correct_meaning === participant_meaning) ? 1 : 0;

	// practice feedback
	if (practice && trial.correct_answer) {
	  const feedbackEl = document.getElementById('practiceFeedback');
	  trialScreen.classList.add('hidden');
	  judgment.classList.add('hidden');
	  feedbackEl.textContent = 
		  (response === trial.correct_answer) ? 'Correct!' : 'Incorrect.';
	  feedbackEl.classList.remove('hidden');
	  await new Promise(resolve => setTimeout(resolve, 1000));
	  feedbackEl.classList.add('hidden');
}

	// save one row per word with judgment info
	wordLevelRows.forEach(row => {
	  const out = Object.assign({}, row, {
		participant_id: participant,
		block: blockName,
		key_mapping: key_mapping,
		judgement_rt: rt_judgment,
		accuracy: accuracy
	  });
	  results.push(out);
	});

	// hide judgment screen for next trial
	judgment.classList.add('hidden');
	trialScreen.classList.remove('hidden');
	}
}

// -------------------- End: download & (optional) send --------------------
function toCSV(rows){
  if(rows.length===0) return '';
  const keys = Object.keys(rows[0]);
  const header = keys.join(',') + '\n';
  const lines = rows.map(r=> keys.map(k=> ((''+(r[k]===undefined?'':r[k])).replace(/,/g,'') ) ).join(','));
  return header + lines.join('\n');
}

downloadBtn.addEventListener('click', ()=>{
  const csv = toCSV(results);
  const blob = new Blob([csv],{type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download = (participant||'participant') + '_results.csv'; a.click();
});

// -------------------- send results to a remote endpoint --------------------
function chunkArray(arr, size) {
  const chunks = [];
  for (let i = 0; i < arr.length; i += size) {
    chunks.push(arr.slice(i, i + size));
  }
  return chunks;
}

const DATA_ENDPOINT = "https://script.google.com/macros/s/AKfycbzIQal-pzsxk3DBDpw-MT4T6dH1Uoh1bzeEfJRyf2YPvzzyPDaRJAN9laBa746JPZfu/exec";

async function sendResults() {
  const savingScreen = document.getElementById('savingScreen');
  const meta = participantDB[participant];

  if (!meta) {
    console.error("No sheet mapping found for participant", participant);
    return;
  }

  // Show saving screen
  trialScreen.classList.add('hidden');
  savingScreen.classList.remove('hidden');

  const batches = chunkArray(results, 600); // about 600 rows per request
  console.log(`Uploading ${results.length} rows in ${batches.length} batches...`);

  for (let i = 0; i < batches.length; i++) {
    const formData = new FormData();
    formData.append('sheet_id', meta.sheet_id);
    formData.append('batch_index', i);
    formData.append('rows', JSON.stringify(batches[i]));

    try {
      await fetch(DATA_ENDPOINT, {
        method: 'POST',
        body: formData
      });
      console.log(`Batch ${i + 1}/${batches.length} uploaded.`);
    } catch (err) {
      console.error(`Failed to send batch ${i + 1}:`, err);
    }
  }

  console.log("All batches uploaded.");

  // Hide saving screen after upload
  savingScreen.classList.add('hidden');
}

</script>
</body>
</html>
